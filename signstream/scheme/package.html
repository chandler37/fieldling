<html><body bgcolor="#FFFFFF"><p>Interfaces for dealing with <I>coding schemes</I>, which describe the allowedstructure of transcripts' annotations. </p><h3>Logical description</h3><P>Coding schemes are formal specifications constraining the ways in which a given transcript may be annotated. This can include defined allowed values, relationshipsbetween different annotations, and even simple data types other than text. <p>Earlier versions of Signstream used a hard-coded <I>&quot;field specification&quot;</I> to constrain the structure of transcripts. This specification, hard-coded into the application, was specific   to American Sign Language annotation, and to the conventions established   by the ASLLRP project at BU. Furthermore, since the structure is always evolving,   this specification is not complete even within the ASLLRP group's annotation   efforts as it was frozen with the release of the current version of SignStream.   To accomodate these two areas of flexibility -- annotation of other domains   than ASL and ongoing evolution of annotation conventions within any    domain -- SignStream 3 adopts a more flexible method of constraining annotations,renamed <i>coding scheme</I> partly to differentiate it from the simplerfield specification of older versions.</p><p>Formally, a coding scheme is a set of <I>scheme fields</I>. These fields correspond   to distinct aspects of linguistic data which can be independently annotated.   For example, in the current convention for annotating ASL, &quot;Head Nod&quot;,   &quot;Eye Brows&quot;, &quot;Main Gloss&quot; are distinct fields. In SignStream's multi-tracked transcripts, each GUI <i>track</i> corresponds to  a specific<i> field</i> from the coding scheme. In this sense a scheme is identical to the older field spec, although the terms <i>track</i> and <i>field</i>are used to distinguish parts of a transcript from the parts of the coding scheme. <P>In addition to a few bits of   data associated with every scheme field -- name, label, ID# (<font color="#FF0000">*</font>)   -- fields may have other properties describing  how the field may be used in transcriptions. This list is currently comprehensive,   but may grow in the future: </p><ul>  <li><b>Time alignment</b> Describes annotations' time-linkage with associated media(e.g. video). The default     is absolute-timing -- each annotation has a start and end time expressed in milleseconds. Two other possibilities are time-linked, where annotations'     start and end times are locked to those of annotations on another track in     the transcript; and per-segment or untimed, where there is only one annotation for     this field per transcript segment as for example an English translation of a signed sequence. </li>  <li><b>Data type</b> Annotations within a field may be textual, graphic, or numeric. In the future other types may be supported. Annotations regardless of typehave a text value (in the case of numeric types simply a string representationof the number).</li>  <li><b>Parent/child</b> Fields may have subordinate fields, or child fields(e.g. a &quot;Hand Sign&quot; could have child fields &quot;Hand     Orientation&quot;, &quot;Hand Aperture&quot;, etc.). This is limited to one level; there are no grandchildren fields. Field X may identify one or moreother fields in the scheme as its children, and each of these fields in turn must identify field X (and only field X) as their parent. </li>  <li><b>State fields</b> State fields are     used to annotate state change events, often applying to the entire transcription. For     example, when signing, typically one hand is the dominant hand, but this is not fixed. If the signer picks up something in their dominant hand, they mayswitch to signing with the other hand. To annotate which hand is currentlydominant, a "Dominant Hand" field could be used, with 2 state-change values"left" and "right". When the value "left" occurs this indicates thatthe left hand has become the dominant hand and remains so until the occuranceof a "right" annotation or until the end of the transcript.  <li><b>Value constraint</b> Does the field have a set of allowed values oris any value legal? The latter case only applies to text-typed fields. For numericfields, a value range may be specified.(<b>NOTE:</b> transcribers may add new values     to defined sets, so these should not be considered <i>fixed</i> sets).   <li><b>Referential</b> There is a requested feature to allow for diectic references     to be annotated. In the abstract this means annotations which logically refer     to earlier annotations (typically within other fields). As an example from     English, in the sentence &quot;John hates peanuts; they cause his head to     swell like a balloon,&quot; the pronoun &quot;his&quot; is a reference     to &quot;John&quot;. An ASL signer might use a similar construct by pointing     to a location in space when first signing &quot;John&quot; and would then     point back to that location when making further references to John. </ul><p><font color="#FF0000">*</font> ID numbers are not part of the canonical coding   scheme, but are used locally. In other words, these numbers should not be considered as consistent from one context to another.</p><p>In addition to these properties, a field whose value constraint is &quot;defined   set&quot; also contains a set of <I>scheme values</I>. Like scheme fields, values   each have unique names, labels, and local ID#s. Graphic fields's values have a graphic, but in implementation this would make use of the ID# and a tile-set graphic associated with the field (therefore graphic fields's values are all ofthe same dimensions and color depth).</ul><h3>Scheme management</h3>A significant difference between coding schemes and the older field specificationis that coding schemes are stored independently of transcripts and are integratedby the application. The exception is that exported XML documents may "flatten" transcripts, replacing references to a separate coding scheme to the (text) values.The older field spec, despite being hard-coded into the application, was redundantly saved within the transcriptdata files. This was necessary since users could add to the hard-coded field spec,but it made it very difficult to propogate additions to the specification among members of a group or even from one document to another for an individualtranscriber.With SignStream 3, all transcripts using the scheme named "ASLLRP" sharea single XML document describing the scheme, and any saved additions or changesto the scheme are immediately available for other transcripts in that installation. When sending transcripts between users, the relevant portions of thescheme (at a minimum) can be sent as part of the transcript XML document and then imported into the local scheme of the recipient, or parsed by other applications. Loading and saving coding schemes is handled through the {@link CodingSchemeManager}, which serves as a facade to the schemes package and a simple CodingScheme factory. The manager loads classes by their unique name, or transparently createsa new scheme if none exists for the given name. All loaded schemes (or schemes created with the manager) are cached in memory and are only updatedon disk when a save or save all operation is requested. An in memory schememay be discarded without saving or reverted to the on-disk version. It isup to client code to request these operations; the manager itself does not track the state of in-memory schemes. Since the {@link CodingScheme} interface is public, it is possible for client code to instantiate a scheme without loading it through the manager.In some cases this is necessary, for instance when importing schemes from otherusers (i.e. from an external file or URL). For this reason the manager supports creation methods to create named, empty schemes, fields, and values that use the same underlying implementation,and an {@link #add(CodingScheme)} method to add such schemes to the in-memory cache, after which the scheme may be saved like any other.</body></html>